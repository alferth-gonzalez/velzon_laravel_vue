# Documentaci√≥n: Handlers vs Services - Diferencias y Cu√°ndo Usar Cada Uno

## üìã √çndice
1. [Introducci√≥n](#introducci√≥n)
2. [¬øQu√© son los Services?](#qu√©-son-los-services)
3. [¬øQu√© son los Handlers?](#qu√©-son-los-handlers)
4. [Diferencias Clave](#diferencias-clave)
5. [Cu√°ndo usar cada uno](#cu√°ndo-usar-cada-uno)
6. [Ejemplos de la Vida Real](#ejemplos-de-la-vida-real)
7. [Patrones y Mejores Pr√°cticas](#patrones-y-mejores-pr√°cticas)
8. [Casos de Uso Comunes](#casos-de-uso-comunes)
9. [Resumen y Recomendaciones](#resumen-y-recomendaciones)

---

## üéØ Introducci√≥n

Una de las confusiones m√°s comunes en la arquitectura DDD es entender cu√°ndo usar **Services** y cu√°ndo usar **Handlers**. Ambos manejan l√≥gica de negocio, pero tienen prop√≥sitos y responsabilidades diferentes.

### **El problema com√∫n:**
- **Services** (Domain) ‚Üí L√≥gica de negocio
- **Handlers** (Application) ‚Üí L√≥gica de negocio
- **¬øCu√°l usar?** ü§î

**La respuesta:** Depende del **prop√≥sito** y **contexto** de la l√≥gica.

---

## üè¢ ¬øQu√© son los Services?

### **Definici√≥n:**
Los **Services** son clases que contienen **l√≥gica de negocio pura** del dominio. Son independientes de frameworks y se enfocan en las reglas de negocio espec√≠ficas.

### **Caracter√≠sticas:**
- **Ubicaci√≥n**: `Domain/Services/`
- **Prop√≥sito**: L√≥gica de negocio pura
- **Independientes**: No dependen de frameworks
- **Reutilizables**: Se pueden usar en m√∫ltiples contextos
- **Sin efectos secundarios**: No manejan HTTP, base de datos, etc.

### **Analog√≠a de la Vida Real:**
Imagina que los **Services** son como **especialistas** en un hospital:

- **Cardi√≥logo**: Sabe todo sobre el coraz√≥n
- **Neur√≥logo**: Sabe todo sobre el cerebro
- **Traumat√≥logo**: Sabe todo sobre huesos

Cada uno es un **experto** en su √°rea espec√≠fica, pero no coordina operaciones completas.

---

## ‚öôÔ∏è ¬øQu√© son los Handlers?

### **Definici√≥n:**
Los **Handlers** son clases que **orquestan** y **coordinan** la l√≥gica de negocio. Unen diferentes Services y manejan el flujo completo de una operaci√≥n.

### **Caracter√≠sticas:**
- **Ubicaci√≥n**: `Application/Handlers/`
- **Prop√≥sito**: Orquestar y coordinar
- **Dependientes**: Pueden depender de frameworks
- **Espec√≠ficos**: Un Handler por Command
- **Con efectos secundarios**: Manejan base de datos, eventos, etc.

### **Analog√≠a de la Vida Real:**
Imagina que los **Handlers** son como **coordinadores de cirug√≠a** en un hospital:

- **Coordinan** a m√∫ltiples especialistas
- **Manejan** el flujo completo de la operaci√≥n
- **Se aseguran** de que todo est√© en orden
- **Gestionan** los recursos necesarios

---

## üîç Diferencias Clave

| Aspecto | Services (Domain) | Handlers (Application) |
|---------|-------------------|------------------------|
| **Ubicaci√≥n** | `Domain/Services/` | `Application/Handlers/` |
| **Prop√≥sito** | L√≥gica de negocio pura | Orquestar y coordinar |
| **Dependencias** | Independientes | Pueden depender de frameworks |
| **Reutilizaci√≥n** | Altamente reutilizables | Espec√≠ficos por Command |
| **Efectos secundarios** | No tienen | S√≠ tienen (DB, eventos, etc.) |
| **Complejidad** | Simples y enfocados | Complejos y coordinadores |
| **Testing** | F√°cil (sin dependencias) | M√°s complejo (con dependencias) |

---

## üéØ Cu√°ndo usar cada uno

### **‚úÖ Services (Domain) - Usar cuando:**

#### **1. L√≥gica de negocio pura:**
```php
// ‚úÖ BIEN - Service con l√≥gica pura
class EmployeeService
{
    public function calculateYearsOfService(Employee $employee): int
    {
        $hireDate = $employee->hireDate();
        $now = new \DateTimeImmutable();
        return $now->diff($hireDate)->y;
    }
    
    public function isEligibleForPromotion(Employee $employee): bool
    {
        $yearsOfService = $this->calculateYearsOfService($employee);
        $hasGoodPerformance = $employee->hasGoodPerformance();
        
        return $yearsOfService >= 2 && $hasGoodPerformance;
    }
}
```

#### **2. Reglas de negocio complejas:**
```php
// ‚úÖ BIEN - Service con reglas complejas
class PayrollService
{
    public function calculateGrossSalary(Employee $employee, int $hoursWorked): float
    {
        $hourlyRate = $employee->hourlyRate();
        
        if ($hoursWorked <= 40) {
            return $hoursWorked * $hourlyRate;
        }
        
        $regularHours = 40;
        $overtimeHours = $hoursWorked - 40;
        $overtimeRate = $hourlyRate * 1.5;
        
        return ($regularHours * $hourlyRate) + ($overtimeHours * $overtimeRate);
    }
    
    public function calculateTaxes(float $grossSalary, string $taxBracket): float
    {
        // L√≥gica compleja de c√°lculo de impuestos
        if ($taxBracket === 'low') {
            return $grossSalary * 0.10;
        } elseif ($taxBracket === 'medium') {
            return $grossSalary * 0.20;
        } else {
            return $grossSalary * 0.30;
        }
    }
}
```

#### **3. Validaciones de negocio:**
```php
// ‚úÖ BIEN - Service con validaciones
class EmailService
{
    public function isValidEmail(string $email): bool
    {
        return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
    }
    
    public function isCorporateEmail(string $email): bool
    {
        $corporateDomains = ['@empresa.com', '@company.com'];
        
        foreach ($corporateDomains as $domain) {
            if (str_ends_with($email, $domain)) {
                return true;
            }
        }
        
        return false;
    }
}
```

### **‚úÖ Handlers (Application) - Usar cuando:**

#### **1. Orquestar m√∫ltiples Services:**
```php
// ‚úÖ BIEN - Handler que orquesta Services
class ProcessPayrollHandler
{
    public function __construct(
        private EmployeeRepositoryInterface $employeeRepository,
        private PayrollService $payrollService, // ‚Üê Service del dominio
        private TaxService $taxService, // ‚Üê Service del dominio
        private DeductionService $deductionService, // ‚Üê Service del dominio
        private PayrollRepositoryInterface $payrollRepository
    ) {}

    public function handle(ProcessPayrollCommand $command): PayrollDTO
    {
        // 1. Obtener empleado
        $employee = $this->employeeRepository->findById($command->employeeId);
        
        // 2. Calcular salario bruto usando Service
        $grossSalary = $this->payrollService->calculateGrossSalary($employee, $command->hoursWorked);
        
        // 3. Calcular impuestos usando Service
        $taxes = $this->taxService->calculateTaxes($grossSalary, $employee->taxBracket());
        
        // 4. Calcular deducciones usando Service
        $deductions = $this->deductionService->calculateDeductions($employee, $grossSalary);
        
        // 5. Calcular salario neto
        $netSalary = $grossSalary - $taxes - $deductions;
        
        // 6. Crear n√≥mina
        $payroll = new Payroll(
            employeeId: $employee->id(),
            grossSalary: $grossSalary,
            taxes: $taxes,
            deductions: $deductions,
            netSalary: $netSalary,
            period: $command->period
        );
        
        // 7. Guardar en base de datos
        $this->payrollRepository->save($payroll);
        
        // 8. Disparar evento
        event(new PayrollProcessed($payroll));
        
        // 9. Retornar DTO
        return $this->convertToDTO($payroll);
    }
}
```

#### **2. Manejar efectos secundarios:**
```php
// ‚úÖ BIEN - Handler con efectos secundarios
class CreateEmployeeHandler
{
    public function __construct(
        private EmployeeRepositoryInterface $employeeRepository,
        private EmployeeService $employeeService, // ‚Üê Service del dominio
        private EventDispatcherInterface $eventDispatcher,
        private NotificationService $notificationService
    ) {}

    public function handle(CreateEmployeeCommand $command): EmployeeDTO
    {
        // 1. Validar datos usando Service
        if (!$this->employeeService->isValidEmployeeData($command)) {
            throw new InvalidEmployeeDataException();
        }
        
        // 2. Crear empleado
        $employee = $this->createEmployee($command);
        
        // 3. Aplicar l√≥gica de negocio del Service
        if ($this->employeeService->isEligibleForPromotion($employee)) {
            $employee->markAsEligibleForPromotion();
        }
        
        // 4. Guardar en base de datos (efecto secundario)
        $this->employeeRepository->save($employee);
        
        // 5. Disparar evento (efecto secundario)
        $this->eventDispatcher->dispatch(new EmployeeCreated($employee));
        
        // 6. Enviar notificaci√≥n (efecto secundario)
        $this->notificationService->sendWelcomeEmail($employee);
        
        // 7. Retornar DTO
        return $this->convertToDTO($employee);
    }
}
```

---

## üè• Ejemplos de la Vida Real

### **Ejemplo 1: Hospital**

#### **Services (Especialistas):**
```php
// Cardi√≥logo - Especialista en coraz√≥n
class CardiologyService
{
    public function diagnoseHeartCondition(Patient $patient): string
    {
        // L√≥gica pura de diagn√≥stico card√≠aco
        if ($patient->hasChestPain() && $patient->hasShortnessOfBreath()) {
            return 'possible_heart_attack';
        }
        
        return 'normal';
    }
    
    public function calculateHeartRate(Patient $patient): int
    {
        // L√≥gica pura de c√°lculo de frecuencia card√≠aca
        return $patient->getPulseRate();
    }
}

// Neur√≥logo - Especialista en cerebro
class NeurologyService
{
    public function diagnoseNeurologicalCondition(Patient $patient): string
    {
        // L√≥gica pura de diagn√≥stico neurol√≥gico
        if ($patient->hasHeadache() && $patient->hasVisionProblems()) {
            return 'possible_migraine';
        }
        
        return 'normal';
    }
}
```

#### **Handler (Coordinador de Cirug√≠a):**
```php
// Coordinador de Cirug√≠a - Orquesta a los especialistas
class HeartSurgeryHandler
{
    public function __construct(
        private CardiologyService $cardiologyService,
        private AnesthesiaService $anesthesiaService,
        private SurgeryRepositoryInterface $surgeryRepository,
        private EventDispatcherInterface $eventDispatcher
    ) {}

    public function handle(PerformHeartSurgeryCommand $command): SurgeryDTO
    {
        // 1. Obtener paciente
        $patient = $this->getPatient($command->patientId);
        
        // 2. Diagnosticar usando Service
        $diagnosis = $this->cardiologyService->diagnoseHeartCondition($patient);
        
        // 3. Preparar anestesia usando Service
        $anesthesia = $this->anesthesiaService->prepareAnesthesia($patient);
        
        // 4. Realizar cirug√≠a
        $surgery = $this->performSurgery($patient, $diagnosis);
        
        // 5. Guardar en base de datos
        $this->surgeryRepository->save($surgery);
        
        // 6. Disparar evento
        $this->eventDispatcher->dispatch(new SurgeryCompleted($surgery));
        
        // 7. Retornar resultado
        return $this->convertToDTO($surgery);
    }
}
```

### **Ejemplo 2: Restaurante**

#### **Services (Chefs Especialistas):**
```php
// Chef de Pasteler√≠a - Especialista en postres
class PastryService
{
    public function createCake(string $type, array $ingredients): Cake
    {
        // L√≥gica pura de creaci√≥n de pasteles
        $recipe = $this->getRecipe($type);
        $cake = new Cake($recipe, $ingredients);
        
        return $cake;
    }
    
    public function calculateBakingTime(Cake $cake): int
    {
        // L√≥gica pura de c√°lculo de tiempo de horneado
        $baseTime = 30; // minutos base
        $sizeMultiplier = $cake->getSize() * 10;
        
        return $baseTime + $sizeMultiplier;
    }
}

// Chef de Cocina - Especialista en platos principales
class KitchenService
{
    public function prepareMainCourse(string $dish, array $ingredients): MainCourse
    {
        // L√≥gica pura de preparaci√≥n de platos principales
        $recipe = $this->getRecipe($dish);
        $mainCourse = new MainCourse($recipe, $ingredients);
        
        return $mainCourse;
    }
}
```

#### **Handler (Ma√Ætre D'):**
```php
// Ma√Ætre D' - Coordina todo el servicio
class DinnerServiceHandler
{
    public function __construct(
        private KitchenService $kitchenService,
        private PastryService $pastryService,
        private OrderRepositoryInterface $orderRepository,
        private NotificationService $notificationService
    ) {}

    public function handle(ProcessDinnerOrderCommand $command): OrderDTO
    {
        // 1. Obtener orden
        $order = $this->getOrder($command->orderId);
        
        // 2. Preparar plato principal usando Service
        $mainCourse = $this->kitchenService->prepareMainCourse(
            $order->getMainDish(),
            $order->getIngredients()
        );
        
        // 3. Preparar postre usando Service
        $dessert = $this->pastryService->createCake(
            $order->getDessert(),
            $order->getDessertIngredients()
        );
        
        // 4. Crear orden completa
        $completeOrder = new CompleteOrder($mainCourse, $dessert);
        
        // 5. Guardar en base de datos
        $this->orderRepository->save($completeOrder);
        
        // 6. Notificar al cliente
        $this->notificationService->notifyOrderReady($completeOrder);
        
        // 7. Retornar resultado
        return $this->convertToDTO($completeOrder);
    }
}
```

---

## üé® Patrones y Mejores Pr√°cticas

### **‚úÖ Patrones Recomendados:**

#### **1. Service para l√≥gica pura:**
```php
// ‚úÖ BIEN - Service con l√≥gica pura
class EmployeeService
{
    public function calculateYearsOfService(Employee $employee): int
    {
        // Solo l√≥gica de negocio, sin dependencias externas
        $hireDate = $employee->hireDate();
        $now = new \DateTimeImmutable();
        return $now->diff($hireDate)->y;
    }
}
```

#### **2. Handler para orquestaci√≥n:**
```php
// ‚úÖ BIEN - Handler que orquesta
class UpdateEmployeeHandler
{
    public function __construct(
        private EmployeeRepositoryInterface $employeeRepository,
        private EmployeeService $employeeService // ‚Üê Usa el Service
    ) {}

    public function handle(UpdateEmployeeCommand $command): EmployeeDTO
    {
        // 1. Obtener empleado
        $employee = $this->employeeRepository->findById($command->employeeId);
        
        // 2. Actualizar datos
        $employee->update(/* ... */);
        
        // 3. Aplicar l√≥gica del Service
        if ($this->employeeService->isEligibleForPromotion($employee)) {
            $employee->markAsEligibleForPromotion();
        }
        
        // 4. Guardar
        $this->employeeRepository->save($employee);
        
        // 5. Retornar DTO
        return $this->convertToDTO($employee);
    }
}
```

### **‚ùå Anti-patrones (Evitar):**

#### **1. Service con dependencias externas:**
```php
// ‚ùå MAL - Service con dependencias externas
class EmployeeService
{
    public function __construct(
        private EmployeeRepositoryInterface $employeeRepository // ‚ùå NO en Service
    ) {}

    public function createEmployee(array $data): Employee
    {
        // ‚ùå Service no debe manejar base de datos
        $employee = new Employee(/* ... */);
        $this->employeeRepository->save($employee);
        return $employee;
    }
}
```

#### **2. Handler sin orquestaci√≥n:**
```php
// ‚ùå MAL - Handler que solo hace una cosa simple
class SimpleCalculationHandler
{
    public function handle(CalculateCommand $command): float
    {
        // ‚ùå Esto deber√≠a ser un Service
        return $command->number1 + $command->number2;
    }
}
```

---

## üîß Casos de Uso Comunes

### **1. CRUD Operations:**

#### **Service (L√≥gica pura):**
```php
class EmployeeService
{
    public function validateEmployeeData(array $data): bool
    {
        // Validaciones de negocio puras
        return !empty($data['first_name']) && 
               !empty($data['last_name']) && 
               $this->isValidEmail($data['email']);
    }
    
    public function calculateEmployeeAge(Employee $employee): int
    {
        // C√°lculo puro
        $birthDate = $employee->birthDate();
        $now = new \DateTimeImmutable();
        return $now->diff($birthDate)->y;
    }
}
```

#### **Handler (Orquestaci√≥n):**
```php
class CreateEmployeeHandler
{
    public function __construct(
        private EmployeeRepositoryInterface $employeeRepository,
        private EmployeeService $employeeService
    ) {}

    public function handle(CreateEmployeeCommand $command): EmployeeDTO
    {
        // 1. Validar usando Service
        if (!$this->employeeService->validateEmployeeData($command->toArray())) {
            throw new InvalidEmployeeDataException();
        }
        
        // 2. Crear empleado
        $employee = new Employee(/* ... */);
        
        // 3. Guardar
        $this->employeeRepository->save($employee);
        
        // 4. Retornar DTO
        return $this->convertToDTO($employee);
    }
}
```

### **2. Operaciones Complejas:**

#### **Services (L√≥gica especializada):**
```php
class PayrollService
{
    public function calculateGrossSalary(Employee $employee, int $hours): float
    {
        // L√≥gica pura de c√°lculo de salario
        return $employee->hourlyRate() * $hours;
    }
}

class TaxService
{
    public function calculateTaxes(float $salary, string $bracket): float
    {
        // L√≥gica pura de c√°lculo de impuestos
        return $salary * $this->getTaxRate($bracket);
    }
}
```

#### **Handler (Coordinaci√≥n):**
```php
class ProcessPayrollHandler
{
    public function __construct(
        private PayrollService $payrollService,
        private TaxService $taxService,
        private PayrollRepositoryInterface $payrollRepository
    ) {}

    public function handle(ProcessPayrollCommand $command): PayrollDTO
    {
        // 1. Calcular salario bruto
        $grossSalary = $this->payrollService->calculateGrossSalary(
            $command->employee, 
            $command->hours
        );
        
        // 2. Calcular impuestos
        $taxes = $this->taxService->calculateTaxes(
            $grossSalary, 
            $command->taxBracket
        );
        
        // 3. Crear n√≥mina
        $payroll = new Payroll($grossSalary, $taxes);
        
        // 4. Guardar
        $this->payrollRepository->save($payroll);
        
        // 5. Retornar DTO
        return $this->convertToDTO($payroll);
    }
}
```

---

## üìù Resumen y Recomendaciones

### **üéØ Regla Pr√°ctica:**

#### **¬øTienes dudas? Preg√∫ntate:**

1. **¬øEs l√≥gica de negocio pura?** ‚Üí **Service**
2. **¬øNecesitas orquestar algo?** ‚Üí **Handler**
3. **¬øEs muy simple?** ‚Üí **Service**
4. **¬øEs complejo y necesita coordinaci√≥n?** ‚Üí **Handler**

### **‚úÖ Services - Usar cuando:**
- L√≥gica de negocio pura
- C√°lculos y validaciones
- Reglas de negocio complejas
- L√≥gica reutilizable
- Sin dependencias externas

### **‚úÖ Handlers - Usar cuando:**
- Orquestar m√∫ltiples Services
- Manejar efectos secundarios
- Coordinar operaciones complejas
- Un Handler por Command
- Con dependencias externas

### **‚ùå NO uses Services cuando:**
- Necesitas acceso a base de datos
- Necesitas manejar HTTP
- Necesitas disparar eventos
- Necesitas orquestar m√∫ltiples servicios

### **‚ùå NO uses Handlers cuando:**
- Solo necesitas l√≥gica de negocio pura
- La l√≥gica es muy simple
- No necesitas orquestar nada

### **üí° Consejo Final:**
**Los Services contienen la l√≥gica de negocio pura, los Handlers la orquestan y coordinan.**

Esta separaci√≥n hace que tu c√≥digo sea m√°s limpio, testeable y mantenible, siguiendo los principios de DDD y Clean Architecture.
